import itertools
import re
import pickle
from dataclasses import dataclass
from pathlib import Path
from strip_ansi import strip_ansi
from typing import Match, Pattern

# Files generated by plugin.py
REPORTFILE = Path.cwd() / "report_objects.bin"
MARKEDTERMINALOUTPUTFILE = Path.cwd() / "marked_output.bin"
UNMARKEDTERMINALOUTPUTFILE = Path.cwd() / "unmarked_output.bin"

# regex matching patterns for Pytest sections
test_session_starts_matcher = re.compile(r"^==.*\stest session starts\s==+")
errors_section_matcher = re.compile(r"^==.*\sERRORS\s==+")
failures_section_matcher = re.compile(r"^==.*\sFAILURES\s==+")
warnings_summary_matcher = re.compile(r"^==.*\swarnings summary\s.*==+")
passes_section_matcher = re.compile(r"^==.*\sPASSES\s==+")
short_test_summary_matcher = re.compile(r"^==.*\sshort test summary info\s.*==+")
lastline_matcher = re.compile(r"^==.*in\s\d+.\d+s.*=+")
ansi_failed_test_name_matcher = re.compile(r"\x1b\[31m\x1b\[1m__+\W(\S+)\W__+\x1b\[0m")
ansi_passed_test_name_matcher = re.compile(r"\x1b\[32m\x1b\[1m__+\W(\S+)\W__+\x1b\[0m")
section_name_matcher = re.compile(r"~~>PYTEST_FOLD_(\w+)")
standard_test_matcher = re.compile(
    r".*\::(\S+)\s(PASSED|FAILED|ERROR|SKIPPED|XFAIL|XPASS)"
)
live_log_testname_matcher = re.compile(r".*::(\S+)", re.MULTILINE)
live_log_outcome_matcher = re.compile(
    r"^(PASSED|FAILED|ERROR|SKIPPED|XFAIL|XPASS)\W.+(\[\W?.*?\])", re.MULTILINE
)

MARKERS = {
    "pytest_fold_test_session_starts": "~~>PYTEST_FOLD_TEST_SESSION_STARTS<~~",
    "pytest_fold_errors_section": "~~>PYTEST_FOLD_ERRORS_SECTION<~~",
    "pytest_fold_failures_section": "~~>PYTEST_FOLD_FAILURES_SECTION<~~",
    "pytest_fold_warnings_summary": "~~>PYTEST_FOLD_WARNINGS_SUMMARY<~~",
    "pytest_fold_passes_section": "~~>PYTEST_FOLD_PASSES_SECTION<~~",
    "pytest_fold_short_test_summary": "~~>PYTEST_FOLD_SHORT_TEST_SUMMARY<~~",
    "pytest_fold_last_line": "~~>PYTEST_FOLD_LAST_LINE<~~",
}


OUTCOMES = (
    "Failures",
    "Passes",
    "Errors",
    "Skipped",
    "Xfails",
    "Xpasses",
)


@dataclass
class SectionInfo:
    """Info relevant to each Pytest output section"""

    name: str = ""
    label: str = ""
    matcher: Match = None
    content: str = r""
    outcome: str = ""


@dataclass
class TestInfo:
    """Info relevant for a single test"""

    title: str = ""
    category: str = ""
    outcome: str = ""
    caplog: str = ""
    capstderr: str = ""
    capstdout: str = ""
    text: str = ""
    keywords: set = ()


class Results:
    """
    This class holds all pertinent information for a given Pytest test run.
    """

    def __init__(self):
        self.reports = []

        self.Sections = self._init_sections()
        self.unmarked_output = self._get_unmarked_output()
        self.marked_output = MarkedSections(self.Sections)
        self.test_results = self._get_test_results()

        # This code presents categorized test results
        self._categorize_tests()
        self._update_testinfo_category()

        self.tests_errors = self._get_result_by_outcome("ERROR")
        self.tests_passes = self._get_result_by_outcome("PASSED")
        self.tests_failures = self._get_result_by_outcome("FAILED")
        self.tests_skipped = self._get_result_by_outcome("SKIPPED")
        self.tests_xfails = self._get_result_by_outcome("XFAIL")
        self.tests_xpasses = self._get_result_by_outcome("XPASS")

        self.tests_all = {}
        self.tests_all.update(self.tests_errors)
        self.tests_all.update(self.tests_passes)
        self.tests_all.update(self.tests_failures)
        self.tests_all.update(self.tests_skipped)
        self.tests_all.update(self.tests_xfails)
        self.tests_all.update(self.tests_xpasses)

        # Dict holding failed testnames and thei ANSI-encoded traceback info
        self.failed_tracebacks = {}

    def _init_sections(self):
        """
        Initialize SectionInfo dataclass instances"""
        return {
            "TEST_SESSION_STARTS": SectionInfo(
                name="TEST_SESSION_STARTS",
                label="Session Start",
                matcher=test_session_starts_matcher,
            ),
            "ERRORS_SECTION": SectionInfo(
                name="ERRORS_SECTION",
                label="Errors",
                matcher=errors_section_matcher,
                outcome="",
            ),
            "FAILURES_SECTION": SectionInfo(
                name="FAILURES_SECTION",
                label="Failures",
                matcher=failures_section_matcher,
            ),
            "WARNINGS_SUMMARY": SectionInfo(
                name="WARNINGS_SUMMARY",
                label="Warnings",
                matcher=warnings_summary_matcher,
            ),
            "PASSES_SECTION": SectionInfo(
                name="PASSES_SECTION", label="Passes", matcher=passes_section_matcher
            ),
            "SHORT_TEST_SUMMARY": SectionInfo(
                name="SHORT_TEST_SUMMARY",
                label="Short Test Summary",
                matcher=short_test_summary_matcher,
            ),
            "LAST_LINE": SectionInfo(
                name="LAST_LINE", label=None, matcher=lastline_matcher
            ),
        }

    def _get_unmarked_output(
        self, unmarked_file_path: Path = UNMARKEDTERMINALOUTPUTFILE
    ) -> list:
        """Get full Pytest terminal output"""
        with open(unmarked_file_path, "r") as umfile:
            return umfile.read()

    def _get_test_results(self):
        """
        Process TestReport objects from Pytest output; remove duplicates;
        extract ANSI-encoded traceback info for failures.
        """
        self.failed_tracebacks = self._get_tracebacks(
            "FAILURES_SECTION", ansi_failed_test_name_matcher
        )
        self.passed_tracebacks = self._get_tracebacks(
            "PASSES_SECTION", ansi_passed_test_name_matcher
        )
        processed_reports = self._process_reports()
        return list({item.title: item for item in processed_reports}.values())

    def _get_tracebacks(self, section_name: str, regex: Pattern) -> dict:
        # get ANSI-coded traceback text for each test in failures section, in the
        # form of a dictionary: {'test_title': 'ansi-encoded traceback text'}

        testname = ""
        tracebacks = {}

        lines = re.split("\n", self.Sections[section_name].content)
        for line in lines:
            result = re.search(regex, line)
            if result:
                testname = result.groups()[0]
                tracebacks[testname] = ""
            else:
                if not testname:
                    continue
                existing_data = tracebacks[testname]
                tracebacks[testname] = existing_data + "\n" + line

        return tracebacks

    def _process_reports(self):
        """Extract individual test results from full list of Pytest's TestReport instances"""

        test_infos = []
        for report in self._unpickle():
            test_info = TestInfo()
            self.reports.append(report)

            # populate the TestInfo instance with pertinent data from report
            test_info.outcome = report.outcome
            test_info.caplog = report.caplog
            test_info.capstderr = report.capstderr
            test_info.capstdout = report.capstdout
            test_info.title = report.head_line
            test_info.keywords = set(report.keywords)

            test_infos.append(test_info)
        return test_infos

    def _update_testinfo_category(self):
        for report, test_info in itertools.product(self.reports, self.test_results):
            # for failed test cases, we want the ANSI coded output, not longreprtext;
            # longreprtext has no ANSI codes and all text will be rendered w/o markup
            if (
                test_info.category == "FAILED"
                and report.when == "call"
                and test_info.title in self.failed_tracebacks
            ):
                test_info.text = self.failed_tracebacks[test_info.title]
                # if test_info.category == "PASSED" and report.when == "call" and test_info.title in self.passed_tracebacks:
                #     test_info.text = self.passed_tracebacks[test_info.title]

    def _update_test_result_by_testname(self, title: str, result: str) -> None:
        for test_result in self.test_results:
            if title == test_result.title:
                test_result.category = result

    def _categorize_tests(self) -> None:
        """
        Extract test title and outcome from each line.

        Line formats are different depending on setting of Pytest config option 'log_cli'.
        Hence the two regex matcher flavors (standard / live_log), and the two
        sections of per-line regex analysys. (Creating a single regex that captures both
        formats reliably was very difficult, hence worked around with with some per-line
        logic.
        """
        look_for_live_log_outcome = False

        for line in self.Sections["TEST_SESSION_STARTS"].content.split("\n"):
            stripped_line = strip_ansi(line).rstrip()

            # Start out by looking for non-live-log results
            standard_match = re.search(standard_test_matcher, stripped_line)
            if standard_match:
                title = standard_match.groups()[0]
                outcome = standard_match.groups()[1]
                if title and outcome:
                    self._update_test_result_by_testname(title, outcome)
                    title = outcome = None
                continue

            # If the line doesn't match non-live-log format, look for live-log matches;
            # outcomes and testnames in separate searches
            live_log_testname_match = re.search(
                live_log_testname_matcher, stripped_line
            )
            if live_log_testname_match:
                title = live_log_testname_match.groups()[0].strip()
                look_for_live_log_outcome = True
                continue

            live_log_outcome_match = re.search(live_log_outcome_matcher, stripped_line)
            if look_for_live_log_outcome and live_log_outcome_match:
                outcome = live_log_outcome_match.groups()[0].strip()
                look_for_live_log_outcome = False
                self._update_test_result_by_testname(title, outcome)
                title = outcome = None

    def _get_result_by_outcome(self, outcome: str) -> None:
        # dict of {testname: log+stderr+stdout) for each test, per-outcome
        if outcome == "FAILED":
            return {
                test_result.title: test_result.text
                for test_result in self.test_results
                if test_result.category == outcome
            }
        else:
            return {
                test_result.title: test_result.text
                + test_result.caplog
                + test_result.capstderr
                + test_result.capstdout
                for test_result in self.test_results
                if test_result.category == outcome
            }

    def _unpickle(self):
        """Unpack pickled Pytest TestReport objects from file"""
        with open(REPORTFILE, "rb") as rfile:
            return pickle.load(rfile)


class MarkedSections:
    """
    This class processes a Pytest output file that has been marked by pytest-fold,
    and identifies its sections. Pytest defines the following possible sections in
    its console output (not all show by default; they are dictated by option settings,
    e.g. in pytest.ini, on cmd line, etc.):

    "=== test session starts ==="
    "=== ERRORS ==="
    "=== FAILURES ==="
    "=== warnings summary ==="
    "=== PASSES ==="
    "=== short test summary info ==="
    "==== failed passed skipped xfailed xpassed warnings errors in 1.23s ==="
    """

    def __init__(
        self, Sections: dict, marked_file_path: Path = MARKEDTERMINALOUTPUTFILE
    ) -> None:
        self.Sections = Sections
        self._marked_lines = self._get_marked_lines(marked_file_path)
        self._sections = self._sectionize(self._marked_lines)
        print("")

    def get_section(self, name: str) -> str:
        # return marked section, or if not found (e.g. didn't occur in output),
        # return blank dict w/ /no section content
        if name in self.Sections:
            return next(
                (section for section in self._sections if name == section.name),
                SectionInfo(),
            )
        else:
            raise NameError(f"Cannot retrieve section by name: '{name}'")

    def _get_marked_lines(
        self, marked_file_path: Path = MARKEDTERMINALOUTPUTFILE
    ) -> list:
        """Return a list of all lines from the marked output file"""
        with open(MARKEDTERMINALOUTPUTFILE, "r") as mfile:
            return mfile.readlines()

    def _line_is_a_marker(self, line: str) -> bool:
        """Determine if the current line is a marker, or part of Pytest output"""
        return (
            line.strip()
            in (
                MARKERS["pytest_fold_test_session_starts"],
                MARKERS["pytest_fold_errors_section"],
                MARKERS["pytest_fold_failures_section"],
                MARKERS["pytest_fold_passes_section"],
                MARKERS["pytest_fold_warnings_summary"],
                MARKERS["pytest_fold_short_test_summary"],
                MARKERS["pytest_fold_last_line"],
            )
            if line.strip()
            else False
        )

    def _sectionize(self, lines: list) -> dict:
        """
        Parse marked lines from test run console output;
        build dictionary of SectionInfo objects
        """
        section_name = ""

        for line in lines:
            if self._line_is_a_marker(line):
                if MARKERS["pytest_fold_last_line"] in line:
                    continue
                section_name = re.search(section_name_matcher, line).groups()[0]
                self.Sections[section_name].content = r""
            elif section_name:
                self.Sections[section_name].content += line
        self.Sections["LAST_LINE"].content = lines[-1]
        return self.Sections
